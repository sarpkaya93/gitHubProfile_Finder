/**
 * @fileoverview Sort keys in JSS
 * @author Lucas L.
 */
'use strict';

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var getStaticPropertyName = require('../helpers/global').getStaticPropertyName;
var jssHelpers = require('../helpers/jss');
var isCSSProperty = jssHelpers.isCSSProperty;
var isPseudoSelector = jssHelpers.isPseudoSelector;
var isCombinatorSelector = jssHelpers.isCombinatorSelector;

const JSS_EXTEND_KEY = 'extend';

module.exports = {
  meta: {
    docs: {
      description: 'require object keys in JSS to be sorted',
      category: 'JSS Styles',
      recommended: false
    },
    fixable: 'code',
    schema: []
  },

  create: function(context) {
    let stack = null;

    return {
      ObjectExpression() {
        stack = {
          upper: stack,
          prevName: null
        };
      },

      'ObjectExpression:exit'() {
        stack = stack.upper;
      },

      Property(node) {
        if (node.parent.type === 'ObjectPattern') {
          return;
        }

        var previousName = stack.previousName;
        var currentName = getStaticPropertyName(node);

        stack.previousName = currentName || previousName;

        if (
          !previousName ||
          !currentName ||
          !(
            isCSSProperty(currentName) ||
            isPseudoSelector(currentName) ||
            isCombinatorSelector(currentName)
          )
        ) {
          return;
        }

        var isValidOrder = (previous, current) => {
          if (previous=== JSS_EXTEND_KEY || current === JSS_EXTEND_KEY) {
            return true;
          }

          if (
            (isPseudoSelector(previous) && isPseudoSelector(current)) ||
            (isCombinatorSelector(previous) && isCombinatorSelector(current))
          ) {
            // console.log(previous ,current);
            return previous <= current;
          }

          if (
            isPseudoSelector(current) ||
            isPseudoSelector(previous) ||
            isCombinatorSelector(current) ||
            isCombinatorSelector(previous)
          ) {
            return current <= previous;
          }

          return previous <= current;
        };

        if (!isValidOrder(previousName, currentName)) {
          context.report({
            node,
            loc: node.key.loc,
            message:
              "Expected object keys to be in ascending order. '{{currentName}}' should be before '{{previousName}}'",
            data: {
              currentName,
              previousName
            }
          });
        }
      }
    };
  }
};
